実行方法
githubよりcloneし、
$ go run main.go 
を実行してください。
実行したら、
タイムアウトの回数N,過負荷となる平均応答時間t,直近の回数m
という形式で入力してください

内容
main関数
まず、３つのパラメーターN,t,mを入力します。
これらのパラメーターをstringからintに変換し、それぞれグローバル変数に代入します。
read_log_fileという関数をよび、logファイルの内容を一行ずつ読み込み、Logという構造体のフィールドに代入していきます。
Logは以下のように定義しています。
type Log struct {
	dateAtime []time.Time logファイルの日時を保持する
	ip        []string logファイルのipを保持しておく
	ping      []string logファイルのpingを保持しておく
}
logファイルのi行目のlogは、この構造体のそれぞれのフィールドの配列のi番目に追加して保持するようにしました。
logファイルの読込が終わったら、server_checkという関数をよびます。
そして、server_checkの処理が終わるまで待機しています。
読み込んだログは、Log型のlogという変数でレシーバーとしてポインタで共有しています。

server_check関数
go funcを使って別のスレッドを生成し、そのスレッドでisOverloadedという過負荷状態になっているサーバーがあるか調べます。
isOverloadedの処理が終了したら、stopというbool型のチャネルの変数に値を送信しています。
メインのスレッドの方では、isBreadServerという関数で、故障しているサーバーがないか確認しています。
log.pingをfor rangeでまわして、pingが-になっているサーバーがあるか確認します。
あれば、そのindexをisBreakServerに渡します。

isOverloaded関数
log_ip_diffsというLog型の配列を生成し、Log型のlogの中身をipで分別します。
そして、log_ip_diffsをfor rangeで回して、slicesにlog_ip_diffsの要素を入れます。
さらに、slicesの中の配列を後ろから回して、直近のｍ回分のpingの合計値を求めます。
その合計値をmで割った時の値がtを超えていたら、過負荷と判定し、過負荷となり始めた日時の要素と、過負荷が終わった日時の要素を探します。
そして、
ip:10.20.30.1/16,status:overloaded, start:2020-10-19 13:32:24 +0000 UTC, end:2020-10-19 13:35:24 +0000 UTC
という形式でファイルに出力しています。

isBreadServer関数
受け取ったindexから故障疑惑のあるサーバーのipを取得します。
カウンター変数を1にします。
そのindexから再びforでループさせ、同一サーバーでタイムアウトがあればカウンター変数を+1します。
同一サーバーでタイムアウトがなくなったら、カウンター変数とタイムアウトの回数Nを比較し、カウンター変数がN以上であれば
ip:192.168.1.1/24,status:break, start:2020-10-19 13:31:34 +0000 UTC, end:2020-10-19 13:34:34 +0000 UTC
という形式でファイルに出力します。
ファイルに出力後、ループを抜け出します。

設問４の部分については実装ができませんでした。
テストデータはlog.txt、出力はoutput.txtです。